<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<head>
  <title>Laurent Kloeble - Java Consultant - Article : 3 Memory Heaps increase</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <link rel="stylesheet" href="assets/css/main.css" />
  <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
</head>
<body class="is-preload">

<!-- Page Wrapper -->
<div id="page-wrapper">

  <!-- Header -->
  <header id="header">
    <h1><a href="index.html">Java Consultant - Laurent Kloeble</a></h1>
    <nav>
      <a href="#menu">Menu</a>
    </nav>
  </header>

  <!-- Menu -->
  <nav id="menu">
    <div class="inner">
      <h2>Menu</h2>
      <ul class="links">
        <li><a href="index.html">Home</a></li>
        <li><a href="technical.html">Technical</a></li>
        <li><a href="articles.html">Articles</a></li>
      </ul>
      <a href="#" class="close">Close</a>
    </div>
  </nav>

  <!-- Wrapper -->
  <section id="wrapper">
    <header>
      <div class="inner">
        <h2>When the heap keeps growing, it‚Äôs not always a memory leak.</h2>
        <p>

          Seeing the heap grow in production is unsettling. The reflex is often immediate: ‚Äúwe probably have a memory leak.‚Äù Sometimes that‚Äôs true. Often, it‚Äôs not that simple.

        </p>
      </div>
    </header>

    <!-- Content -->
    <div class="wrapper">
      <div class="inner">

        <p>


          A growing heap is a <b>signal</b>.<br>
          What matters is <b>what kind of signal</b>, and <b>over what time horizon</b>.<br>
          <br>
          üß© In production Java systems, heap growth usually falls into one (or more) of three broad patterns.<br>
          Each of them tells a very different story about the system.<br>

          <hr>

          <h3>#1 Warmup - growth as a normal phase of life</h3>

          Heap growth during startup is often treated as a transient inconvenience.<br>
          In reality, it is frequently a <b>designed phase</b> of the system.<br>
        <br>
          Modern Java applications rarely start ‚Äúfully formed‚Äù. They warm up.<br>
        <br>
          Caches populate. <br>
          Metadata loads.<br>
          Code paths become hot.<br>
          Lazy components are instantiated only when first needed.<br>
        <br>
          In large business monoliths, this warmup can be intentionally <b>stretched</b>.<br>
        <br>
          Architectural choices such as:<br>
          <ul>
          <li>deferred initialization,
          <li>lazy-loading of heavy subsystems,
          <li>progressive cache filling,
          <li>staged activation of business features,
          </ul>

        can push the system‚Äôs <i>nominal</i> memory plateau far beyond the first few minutes.
        <br>
          In some environments, reaching steady state can take <b>tens of minutes</b> ‚Äî sometimes <b>hours</b>.<br>
          And that can be perfectly fine.<br>
        <br>
          ‚ö†Ô∏è The risk here is not technical. It‚Äôs organizational.<br>
        <br>
          If the team responsible for operations is used to applications that stabilize in two or three minutes, handing them a system whose heap reaches its plateau after two hours is a recipe for misunderstanding.<br>
        <br>
          Alerts fire.<br>
          Restarts happen.<br>
          ‚ÄúWell-intentioned‚Äù corrective actions are taken against a system that is behaving exactly as designed.<br>
        <br>
          This is not a JVM problem.<br>
          It‚Äôs a <b>shared understanding problem</b>.<br>
        <br>
          A warmup strategy only works if it is <b>explicitly communicated</b> to the teams who monitor and operate the system.<br>

        <style>
          .figure-wide {
            margin: 2rem 0;
          }
          .figure-wide img {
            display: block;
            max-width: 100%;
            height: auto;
            border-radius: 10px;
          }
          .figure-wide figcaption {
            margin-top: 0.75rem;
            font-size: 0.95rem;
            line-height: 1.5;
            opacity: 0.9;
          }
        </style>

        <figure class="figure figure-wide">
          <img
                  src="images/article3heaps_plateau.svg"
                  alt="Heap usage over time: gradual warmup phase followed by a stable plateau with small oscillations (healthy baseline)."
                  loading="lazy"
                  decoding="async"
                  width="1200"
                  height="675"
          />

          <figcaption>
            <strong>Scenario 1 ‚Äî Warmup then plateau (healthy baseline).</strong>
            The heap rises during startup as the system initializes, loads classes, builds internal structures, and warms caches.
            Once steady-state traffic begins, usage stabilizes around a nominal level.
            Small oscillations are expected: allocation bursts and young collections create normal ‚Äúbreathing‚Äù without any long-term upward drift.
          </figcaption>
        </figure>



        <hr>

        <h3> #2 Retained objects - when memory stops being released</h3>

          Not everything in memory is meant to be collected quickly.<br>
        <br>
          Long-lived objects are a normal part of most systems:
        <ul>
        <li>active sessions,
          <li>reference data,
          <li>caches,
          <li>compiled expressions,
          <li>internal registries.
        </ul>

          The presence of such objects does **not** indicate a leak.<br>
        <br>
        The problem begins when objects that are <i>functionally releasable</i> are not released.<br>
        <br>
          This distinction matters.<br>
        <br>
          A memory leak in Java is rarely ‚Äúan object that should not exist‚Äù.<br>
          It is more often:
          <ul>
        <li>an object that <i>used to be relevant</i>,
            <li>that has quietly outlived its usefulness,
            <li>because something is still referencing it.
          </ul>

          The leak is frequently <b>indirect</b>.<br>
        <br>
          The retained object may be small.<br>
          The structure holding onto it may look harmless.<br>
          The functional code may have already moved on.<br>
        <br>
          From the outside, what you see is simple:<br>
          the heap grows, and never quite settles.<br>
        <br>
          üß© This is where many teams get stuck.<br>
        <br>
          The JVM keeps running.<br>
          GC keeps working.<br>
          Nothing crashes immediately.<br>
        <br>
          So the system is given more memory.<br>
          Or restarted periodically.<br>
        <br>
          Both actions reduce pressure ‚Äî without restoring understanding.<br>
        <br>
        <figure class="figure figure-wide">
          <img
                  src="images/article3heaps_leak.svg"
                  alt="Heap usage over time showing a slow but continuous upward trend after warmup, without returning to a stable plateau."
                  loading="lazy"
                  decoding="async"
                  width="1200"
                  height="675"
          />

          <figcaption>
            <strong>Scenario 2 ‚Äî Retention growth (functional memory leak).</strong>
            After the initial warmup, heap usage never truly stabilizes.
            Objects that could be released from a business perspective remain reachable, preventing the system from reaching a steady-state plateau.
            The growth is often slow and deceptive: the application may run for days or weeks before memory pressure becomes critical.
            Garbage collection continues to operate correctly ‚Äî it simply has nothing eligible to reclaim.
          </figcaption>
        </figure>


        <hr>

        <h3>#3 Promotion storms - growth without a leak</h3>

          The third pattern is the most deceptive.<br>
        <br>
          A promotion storm occurs when objects survive just long enough to be promoted into old generation, but not long enough to justify their cost.<br>
        <br>
          The heap grows.<br>
          Old generation occupancy increases.<br>
          GC activity intensifies.<br>
        <br>
          Performance degrades.<br>
          Latency spikes.<br>
          SLA dashboards look unhealthy.<br>
        <br>
          And yet ‚Äî the heap is not filling up.<br>
        <br>
          There may be plenty of free memory.<br>
          There may never be an OOM.<br>
        <br>
          This is not a leak.<br>
        It is a <b>pressure problem</b>.
        <br>
        üéØ The key confusion here is between <i>volume</i> and <i>rhythm</i>.<br>
        <br>
          The system isn‚Äôt necessarily storing too much.<br>
          It‚Äôs allocating, promoting, and collecting at a pace that hurts throughput and tail latency.<br>
        <br>
          In live production debugging sessions, this pattern is particularly dangerous.<br>
        <br>
          Under pressure, teams look at:
          <ul>
          <li>rising old gen,
            <li>frequent GC,
            <li>degraded response times,
          </ul>
          and conclude that a leak is underway.<br>
        <br>
          Actions follow.<br>
          Heap size increases.<br>
          Restarts are scheduled.<br>
        <br>
          The system survives ‚Äî but the diagnosis remains wrong.<br>
        <br>
        <figure class="figure figure-wide">
          <img
                  src="images/article3heaps_storm.svg"
                  alt="Heap usage over time showing a sudden spike caused by promotion pressure, followed by a gradual recovery as garbage collection regains control."
                  loading="lazy"
                  decoding="async"
                  width="1200"
                  height="675"
          />

          <figcaption>
            <strong>Scenario 3 ‚Äî Promotion storm (allocation pressure, not a leak).</strong>
            During periods of intense allocation, large volumes of short-lived objects survive young collections and are prematurely promoted.
            Heap usage rises sharply, often triggering alarmist reactions.
            Yet, once allocation pressure drops and the collector catches up, memory usage recedes.
            This pattern can severely impact latency and SLAs, even though it does not lead to an inevitable out-of-memory condition.
          </figcaption>
        </figure>



        <br>
          Promotion storms punish performance.<br>
          They do not necessarily threaten immediate survival.<br>

          <hr>

          <h3>The cost of reacting too fast</h3>

          Across all three patterns, the danger is the same.
          <ul>
          <li>Increasing the heap ‚â† understanding
            <li>Restarting the JVM ‚â† fixing
            <li>Every ‚Äúpragmatic‚Äù workaround carries hidden cost
          </ul>

          Sometimes that cost is infrastructure.<br>
          Sometimes it is operational fatigue.<br>
          Sometimes it is risk quietly carried by the team.<br>
        <br>
          What works today may become tomorrow‚Äôs incident.<br>

          <hr>

        <h3>Conclusion</h3>

          üéØ A growing heap is not a verdict.<br>
          It‚Äôs a question.<br>
        <br>
        Sometimes the answer is <i>‚Äúeverything is fine.‚Äù</i><br>
          Sometimes it‚Äôs <i>‚Äúwe‚Äôre retaining too much.‚Äù</i><br>
          Sometimes it‚Äôs <i>‚Äúwe‚Äôre putting too much pressure on the system.‚Äù</i><br>
        <br>
          The real risk is not choosing the wrong fix.<br>
          It‚Äôs never being sure what you‚Äôre fixing.<br>
        <br>
          Rebooting works.<br>
          Adding memory works.<br>
          Until they become the most expensive parts of the system.<br>
        <br>
          Understanding the difference doesn‚Äôt require a rewrite.<br>
          It requires looking at the right signals ‚Äî over the right time horizon.<br>

          <hr>

          if you‚Äôre dealing with a production system where memory behavior is unclear, unstable, or slowly becoming a risk,<br>
          I work with teams to analyze what‚Äôs actually happening ‚Äî and to decide what‚Äôs worth fixing, and what isn‚Äôt.<br>
        <br>
          You can reach me here : <a href="mailto:contact@lkloeble.dev">contact@lkloeble.dev</a>





        </p>


      </div>
    </div>

  </section>

</div>

<!-- Scripts -->
<script src="assets/js/jquery.min.js"></script>
<script src="assets/js/jquery.scrollex.min.js"></script>
<script src="assets/js/browser.min.js"></script>
<script src="assets/js/breakpoints.min.js"></script>
<script src="assets/js/util.js"></script>
<script src="assets/js/main.js"></script>

</body>
</html>